@startuml Eriantys

class AssistantCard {
    -motherNatureMaxMoves : Int
    -turnPriority : Int

    +AssistantCard(turnPriority : int, motherNatureMaxMoves : int)
    +getMotherNatureMaxMoves() : int
    +getTurnPriority() : int
    {static}+getDefaultDeck() : List<AssistantCard>
}

class Game {
    -players : List<Player>
    -numberOfPlayers : int //todo: maybe change this
    -islands : List<Island>
    -studentsBag : RandomizedStudentsContainer
    'relative to islands index, or alternatively we can link directly the island'
    -motherNaturePosition : int
    -round : Round
    -characterCards : List<CharacterCard> //3 cards selected for this game
    -currentProfessors : Map<Student, Player>
    -gameState : Game.State

    +Game(int numberOfPlayers)
    -initializeIslands()
    +startGame()
    +newRound()
    +selectCloud(cloud : StudentsContainer, player : Player)
    +addPlayer(nickname : String) : Player
    +moveMotherNature(int steps)
    -calculateInfluenceOnCurrentIsland()
    +calculateInfluenceOnIsland(island : Island)
    +useCharacterCard(player : Player, card : CharacterCard)
    -calculateInfluenceOfPlayer(island : Island, player : Player) : int
    -checkAndMergeIslands()
    +getCurrentIsland() : Island
    -calculateMotherNatureIndex(int steps) : int
    +getPlayers() : List<Player>
    +getNumberOfPlayers() : int
    +getCurrentNumberOfPlayers() : int
    +getIslands() : List<Island>
    +getMotherNaturePosition() : int
    +getCurrentRound : Round
    +getCharacterCards() : List<CharacterCard>
    +getProfessors() : Map<Student, Player>
    +getGameState() : Game.State
    +pauseGame()
    +restartGame()
}

enum Game.State {
    CREATED,
    STARTED,
    PAUSED,
    FINISHED
}

class Round {
    playedAssistantCards : SortedMap<Player, AssistantCard>
    playedCharacterCards : SortedMap<Player, CharacterCard>

    clouds : ArrayList<StudentsContainer> //max students = 3 or 4
    iterator() : Iterable<Player>
}

abstract AStudentsContainer {
    -students : Map<Student, Integer>
    -maxSize : int

    +AStudentsContainer()
    +AStudentsContainer(maxSize : int)
    +getSize() : int
    +setMaxSize(maxSize : int)
    +getStudents() : Map<Student, Integer>
    +getCountForStudent(student : Student) : int
}

class RandomizedStudentsContainer {
    -random : Random

    +RandomizedStudentsContainer(studentsPerColor : int)
    +pickOneRandom() : Student
    +pickManyRandom(howMany : Integer) : StudentsContainer
}

class StudentsContainer {
    +StudentsContainer()
    +StudentsContainer(maxSize : int)
    +StudentsContainer(studentsContainer : AStudentsContainer)
    +StudentsContainer(studentsContainer : AStudentsContainer, maxSize : int)
    +addStudent(student : Student)
    +addStudents(student : Student, howMany : int)
    +removeStudent(student : Student)
    +addAll(anotherContainer : AStudentsContainer)
    +removeAll(anotherContainer : AStudentsContainer)
    '+addOnStudentNumberReachedListener(student : Student, count : int) //for coins'
}

class Player {
    -nickname : String
    -entrance : StudentsContainer
    -school : StudentsContainer
    -towersCount : int
    -towerColor : Tower
    -deck : Map<AssistantCard, Boolean> //<card, usedOrNot>
    -coins : int = 1

    +Player(nickname : String, towerColor : Tower, numberOfPlayers : int)
    +getNickname() : String
    +getTowersCount() : int
    +setTowersCount(towersCount : int)
    +getTowerColor() : Tower
    +setCoins(coins : int)
    +getCoins() : int
    +addCloudToEntrance(cloud : StudentsContainer)
}

class Island {
    -students : StudentsContainer
    -towersCount : int = 0
    -towerColor : Tower
    -noEntry : boolean = false

    +Island()
    +Island(defaultStudent : Student)
    +getSize() : int //it's determined by looking at towers.size
    +getTowersCount() : int
    +getTowerColor() : int
    +getStudents() : StudentsContainer
    +addStudent(student : Student)
    +merge(anotherIsland : Island)
    +setConquered(towerColor : Tower)
    +isConquered() : boolean
    +isNoEntry() : boolean
    +setNoEntry() : boolean
    +isMergeCompatible(anotherIsland : Island) : boolean
}

abstract InfluenceCalculator {
    +calculateInfluence(island : Island, ... professors)
    -calculateTowersInfluence() : int
    -calculateStudentsInfluence() : int
}

class NoTowersInfluenceCalculator {
    {method}@override
    -calculateTowersInfluence() : int
}

class AdditionalPointsInfluenceCalculator {
    -player : Player
    {method}@override
    +calculateInfluence() : int
}

class NoColorInfluenceCalculator {
    -student : Student
    {method}@override
    +calculateStudentsInfluence() : int
}

abstract CharacterCard {
    cost : Int

    +getCost() : Int
    +getMotherNatureAdditionalMoves() : Int

    --
    //used at the beginning of the game
    {static}+generateRandomCards() : ArrayList<CharacterCard[3]>
}

abstract InfluenceCharacterCard {
    +getInfluenceCalculator() : InfluenceCalculator
}

class FarmerCharacterCard {
    //take control of the professors of a color if players
    //have the same number of students for that color
    'redefine cost'
    cost : Int = 2

    {method}@override
    +getInfluenceCalculator() : InfluenceCalculator
}

class HeraldCharacterCard {
    //choose an island and calculate influence on that island
    'redefine cost'
    cost : Int = 3
    island : Island
}

class PostmanCharacterCard {
    //2 additional moves for motehr nature
    'redefine cost'
    cost : Int = 1
}

class GrandmaCharacterCard {
    //no entry on the selected island
    'redefine cost'
    cost : Int = 2
    island : Island
}

class CentaurCharacterCard {
    //no towers in influence
    'redefine cost'
    cost : Int = 3

    {method}@override
    +getInfluenceCalculator() : InfluenceCalculator
}

class MinstrelCharacterCard {
    //swap two students between school and entrance
    studentsToRemove : StudentsContainer
    studentsToAdd : StudentsContainer

    'redefine cost'
    cost : Int = 1
}

class KnightCharacterCard {
    //2 additional points in influence
    'redefine cost'
    cost : Int = 2

    {method}@override
    +getInfluenceCalculator() : InfluenceCalculator
}

class MushroomManCharacterCard {
    //no color in influence
    'redefine cost'
    cost : Int = 3

    {method}@override
    +getInfluenceCalculator() : InfluenceCalculator
}

enum Tower {
    WHITE
    BLACK
    GREY
}

enum Student {
    YELLOW
    BLUE
    GREEN
    RED
    PINK
}

/'
class Client {
    clientSocket : Socket

    +sendMessage(message : Message)
    +addMessageReceivedObserver()
}

interface MessageReceivedObserver {
    onMessageReceived(message : Message)
}

class Server {
    serverSocket : Socket
    activeGames : ArrayList<Game>

    +getInstance() : Server
    +startServer()
}

class App {
    +{static} main
}

interface Serializable {
    ...
}

abstract Message {
    parse()
}

interface Exportable {
    exportToJson() : String
    importFromJson(json : String)
}
'/

Game "2..4" *-- Player
Game "1" *-- RandomizedStudentsContainer
Game "12" *-- Island
Game *-- Round
Game "3" *-- CharacterCard
Game "1" *-- Game.State

Player "10" *-- AssistantCard
'Player --> Tower'
Player "2" *-- StudentsContainer

StudentsContainer --|> AStudentsContainer
RandomizedStudentsContainer --|> AStudentsContainer

'Student --> AStudentsContainer'

Island "1" *-- StudentsContainer


InfluenceCharacterCard --> InfluenceCalculator
InfluenceCharacterCard --|> CharacterCard

FarmerCharacterCard --|> InfluenceCharacterCard
CentaurCharacterCard --|> InfluenceCharacterCard
KnightCharacterCard --|> InfluenceCharacterCard
MushroomManCharacterCard --|> InfluenceCharacterCard

HeraldCharacterCard --|> CharacterCard
PostmanCharacterCard --|> CharacterCard
GrandmaCharacterCard --|> CharacterCard
MinstrelCharacterCard --|> CharacterCard


NoTowersInfluenceCalculator --|> InfluenceCalculator
AdditionalPointsInfluenceCalculator --|> InfluenceCalculator
NoColorInfluenceCalculator --|> InfluenceCalculator

@enduml