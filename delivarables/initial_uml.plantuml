@startuml Eriantys

class AssistantCard {
    motherNatureMaxMoves : Int
    turnPriority : Int

    {static}+getDeck() : ArrayList<AssistantCard>[10]
}

class Game {
    players : Player[3]
    islands : Island[12]
    studentsBag : StudentsBag
    'relative to islands index, or alternatively we can link directly the island'
    motherNaturePosition : Int
    rounds : ArrayList<Rounds>
    characterCards : ArrayList<CharacterCard>[3]

    currentInfluence

    +initializeGame()
}

class Round {
    playedCards : SortedMap<Player, AssistantCard>
    clouds : ArrayList<Set<Student>[N+1]>[N]
    actions : ArrayList<Action>
    iterator() : Iterable<Player>
}

class Action {

}

class StudentsBag {
    'shuffled once, only when created'
    -students : Set<Student>[120]

    +pickRandom(howMany : Int) : Set<Student>[howMany]
}

class Player {
    nickname : String
    entrance : Set<Student>[9]
    towers : Set<Tower>[8]
    'todo: use 5 different arrays'
    students : Student[]
    towers : Tower[]
    deck : ArrayList<AssistantCard>
    coins : Int = 1
    client : Client

    +calculateInfluence(island : Island) : Int
}

/'
useless and wrong

interface RandomPickable {
    +pickRandom(howMany : Int) : ArrayList<Student>
}
'/

/' removed for now
class GroupOfIsland {

}
'/

class Island {
    students : ArrayList<Student>
    towers : ArrayList<Tower>
    --
    //it's possible to determine the size of the island by simply looking at towers.size
    +merge(anotherIsland : Island) : Island
}

'abstract Card {}'

abstract CharacterCard {
    cost : Int
    used : Int
    'same for everyone: cost + 1 * (used > 0)'

    +getCost() : Int
    --
    //used at the beginning of the game
    {static}+generateRandomCards() : ArrayList<CharacterCard[3]>
}

class MonkCharacterCard {
    'redefine cost'
    cost : Int = 1
}

class FarmerCharacterCard {
    'redefine cost'
    cost : Int = 2
}

class HeraldCharacterCard {
    'redefine cost'
    cost : Int = 3
}

class PostmanCharacterCard {
    'redefine cost'
    cost : Int = 1
}

class GrandmaCharacterCard {
    'redefine cost'
    cost : Int = 2
}

class CentaurCharacterCard {
    'redefine cost'
    cost : Int = 3
}

class JesterCharacterCard {
    'redefine cost'
    cost : Int = 1
}

class KnightCharacterCard {
    'redefine cost'
    cost : Int = 2
}

class Tower {
    color : Tower.Color
}

enum Tower.Color {
    WHITE
    BLACK
    GREY
}


class Student {
    color : Student.Color
}

enum Student.Color {
    YELLOW
    BLUE
    GREEN
    RED
    PINK
}

class Client {
    clientSocket : Socket

    +sendMessage(message : Message)
    +addMessageReceivedObserver()
}

interface MessageReceivedObserver {
    onMessageReceived(message : Message)
}

class Server {
    serverSocket : Socket
    activeGames : ArrayList<Game>

    +getInstance() : Server
    +startServer()
}

class App {
    +{static} main
}

interface Serializable {
    ...
}

abstract Message {
    parse()
}

interface Exportable {
    exportToJson() : String
    importFromJson(json : String)
}

Game "2..4" *-- Player
Game "1" *-- StudentsBag
Game "12" *-- Island
Game *-- Round
Game "3" *-- CharacterCard

Player "10" *-- AssistantCard
Player *-- Tower
Player *-- Student

Island *-- Student
Island *-- Tower

Tower --> Tower.Color

Student --> Student.Color

StudentsBag *-- Student

'Round --> AssistantCard'

/'
StudentsBag ..|> RandomPickable
CharacterCardDeck ..|> RandomPickable
'/

Message ..|> Serializable

/'
CharacterCard --|> Card
AssistantCard --|> Card
'/

MonkCharacterCard --|> CharacterCard
FarmerCharacterCard --|> CharacterCard
HeraldCharacterCard --|> CharacterCard
PostmanCharacterCard --|> CharacterCard
GrandmaCharacterCard --|> CharacterCard
CentaurCharacterCard --|> CharacterCard
JesterCharacterCard --|> CharacterCard
KnightCharacterCard --|> CharacterCard


Client --> Message

Server --> Message

'Player --> Client'

App --> Server
Server --> Client

@enduml